extends Control
class_name 连接代理
## 用于管理嵌套或连接功能。
## 可接受一个配置文件，在进入场景树时执行其[method 连接配置.执行配置]。

## 若该配置文件不为空，则自动加载该配置文件，并执行其[method 连接配置.执行配置]。
@export var 配置文件: 连接配置

## 该连接代理的名称，可被用于UI显示和报错信息。
@export var 名称: String

## 该连接代理所归属的另一个连接代理。与接收者的区别是，接收者可以有多个，发送者只能有一个。
@export var 发送者: 连接代理: 
	set = _设置发送者

## 当该连接代理作为一个接收者被断开后，会将发送者设置为默认发送者
@export var 默认发送者:连接代理 = null

var _接收者: Array[连接代理] = []

signal 接收者改变(_发送者: 连接代理, 是_添加: bool, 接收者: 连接代理)
signal 发送者改变(自身:连接代理, 新发送者:连接代理)
signal 连接(连接代理_:连接代理, 接收者:连接代理, 连接代理_为发送者:bool)
signal 断开(连接代理_:连接代理, 接收者:连接代理)


## 连接自己的接收者改变、发送者改变、连接、断开信号，以便在接收到信号时能够自动处理。
func _init():
	connect("连接",_接收_连接)
	connect("断开",_接收_断开)
	connect("接收者改变",当接收者改变)
	connect("发送者改变",当发送者改变)


## 若配置文件不为空，则在进入场景树时执行[method 连接配置.执行配置]。
## 无法更早，因为直到对象被实例化并添加到场景树之后，属性才会被设置为编辑器中指定的值，之前则是默认值。
func _enter_tree() -> void:
	if 配置文件:
		配置文件.执行配置(self)


## 当接收者改变时被调用的虚方法
@warning_ignore("unused_parameter")
func 当接收者改变(_自身: 连接代理, 是_添加: bool, 接收者: 连接代理) -> void:
	pass


## 当发送者改变时被调用的虚方法
@warning_ignore("unused_parameter")
func 当发送者改变(_自身: 连接代理, 新接收者: 连接代理) -> void:
	pass


## 令连接代理_与该连接代理连接。
func 连接到(连接代理_: 连接代理, 连接代理_为发送者: bool) -> void:
	emit_signal("连接", 连接代理_, self, 连接代理_为发送者)


## 令连接代理_与该连接代理断开。
func 断开于(连接代理_: 连接代理):
	emit_signal("断开", 连接代理_, self)


## 获取接收者数组。并非返回引用本身，而是复制。
func 获取_接收者() -> Array[连接代理]:
	return _接收者.duplicate()


## 获取接收者数量。
func 接收者_数量() -> int:
	return _接收者.size()


## 判断两个连接代理之间是否存在连接。
## 注意，若存在单向连接，会根据断开单向的值对连接代理间的连接状态进行纠正，此时返回值与断开单向的值相同。
static func 存在连接(连接代理A: 连接代理, 连接代理B: 连接代理, 断开单向: bool = true) -> bool:
	if (连接代理A.发送者 == 连接代理B) and (连接代理A in 连接代理B.获取_接收者()):
		return true
	if (连接代理B.发送者 == 连接代理A) and (连接代理B in 连接代理A.获取_接收者()):
		return true
	if not 存在单向连接(连接代理A, 连接代理B, 断开单向):
		return false
	return 断开单向


## 判断两个连接代理之间是否存在单向连接。注意，无论返回值如何，都会根据断开单向的值对连接状态进行纠正。
## 在存在单向连接时，若断开连接为true，则会断开单向连接；若断开连接为false，则会补全为正常连接。
static func 存在单向连接(连接代理A: 连接代理, 连接代理B: 连接代理, 断开单向: bool = true) -> bool:
	if 连接代理A == 连接代理B:
		push_warning(连接代理A._信息() + "  自己诊断与自己是否存在单向连接")
		return false
	if (连接代理A.发送者 == 连接代理B) and (连接代理A not in 连接代理B.获取_接收者()):
		if 断开单向:
			连接代理A.发送者 = null
		else:
			连接代理B._接收者_添加(连接代理A)
		return true
	elif (连接代理B.发送者 == 连接代理A) and (连接代理B not in 连接代理A.获取_接收者()):
		if 断开单向:
			连接代理B.发送者 = null
		else:
			连接代理A._接收者_添加(连接代理A)
		return true
	return false


func _接收_连接(连接代理_: 连接代理, 目标: 连接代理, 连接代理_为发送者: bool) -> void:
	if 连接代理_ == self:
		push_warning(连接代理_._信息() + "  自己当自己的发送者")
		return
	if 连接代理_为发送者:
		# 连接代理_希望成为发送者，将目标添加为连接代理_的接收者
		连接代理_._接收者_添加(目标)
		# 目标的发送者设置为连接代理_
		发送者 = 连接代理_
	else:
		# 连接代理_希望成为接收者，将连接代理_添加到自身的接收者列表中
		_接收者_添加(连接代理_)
		# 连接代理_的发送者设置为自身
		连接代理_.发送者 = self


func _接收_断开(连接代理A:连接代理, 连接代理B: 连接代理) -> void:
	if 连接代理A.发送者 == 连接代理B:
		连接代理A._设置发送者(默认发送者)
		连接代理B._接收者_删除(连接代理A)
		print(连接代理B)
	elif 连接代理B.发送者 == 连接代理A:
		print(连接代理A)
		连接代理B._设置发送者(默认发送者)
		连接代理A._接收者_删除(连接代理B)


func _设置发送者(新发送者: 连接代理) -> void:
	发送者 = 新发送者
	emit_signal("发送者改变", self, 新发送者)


func _接收者_添加(连接代理_: 连接代理) -> void:
	if 连接代理_ in _接收者 :
		return
	_接收者.append(连接代理_)
	emit_signal("接收者改变", self, true, 连接代理_)


func _接收者_删除(连接代理_: 连接代理) -> void:
	if 连接代理_ in _接收者:
		_接收者.erase(连接代理_)
		emit_signal("接收者改变", self, false, 连接代理_)


func _接收者_清空() -> void:
	for 连接代理_ in _接收者.duplicate():
		_接收者_删除(连接代理_)
	_接收者.clear()


func _信息() -> String:
	return str(self) + "  |名称： " + 名称 + "  |接收者： " + str(_接收者) + "  |发送者： " + str(发送者)

